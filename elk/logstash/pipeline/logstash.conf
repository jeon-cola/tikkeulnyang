input {
  beats {
    port => 5044
  }
  tcp {
    port => 5000
    codec => line
  }
}

filter {
  # 1차 파싱: 이중 인코딩된 문자열을 JSON으로
  json {
    source => "message"
    target => "decoded"
    skip_on_invalid_json => true
    remove_field => ["message"]
  }

  # 2차 파싱: decoded에 있는 실제 JSON 파싱
  if [decoded][event_type] {
    mutate {
      add_field => {
        "event_type" => "%{[decoded][event_type]}"
        "email" => "%{[decoded][email]}"
        "ip" => "%{[decoded][ip]}"
        "user_agent" => "%{[decoded][user_agent]}"
        "role" => "%{[decoded][role]}"
        "logger_name" => "%{[decoded][logger_name]}"
      }
    }

    # 태깅
    if [event_type] == "auto_login" or [event_type] == "login_success" {
      mutate { add_tag => [ "authentication_success" ] }
    }

    if [event_type] == "login_attempt" {
      mutate { add_tag => [ "security_event" ] }
    }

    if [event_type] in ["login_error", "login_anomaly"] {
      mutate { add_tag => [ "security_alert" ] }
    }
  }
}



output {
  # 콘솔 디버깅용 출력
  stdout {
    codec => rubydebug
  }

  # raw message 디버깅용
  file {
    path => "/tmp/debug_raw_message.log"
    codec => rubydebug
  }

  # TCP로 들어온 message를 그대로 보는 로그 (우리가 추가한 디버깅용 로그)
  file {
    path => "/tmp/debug_tcp_input.log"
    codec => line { format => "FROM TCP: %{message}" }
  }

  # 기본 로그 저장
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "app-logs-%{+YYYY.MM.dd}"
  }

  # 보안 이벤트 전용 인덱스
  if "security_event" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "security-events-%{+YYYY.MM.dd}"
    }
  }

  # 인증 성공 이벤트 전용 인덱스
  if "authentication_success" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "authentication-success-%{+YYYY.MM.dd}"
    }
  }

  # 보안 알림 인덱스
  if "security_alert" in [tags] {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "security-alerts-%{+YYYY.MM.dd}"
    }
  }
}
